
1. Что такое принцип SOLID? Расскажите, какие принципы он включает.

SOLID — это набор из 5 принципов объектно-ориентированного проектирования:
    S – Single Responsibility Principle (Принцип единственной ответственности)
    O – Open/Closed Principle (Принцип открытости/закрытости)
    L – Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
    I – Interface Segregation Principle (Принцип разделения интерфейса)
    D – Dependency Inversion Principle (Принцип инверсии зависимостей)

2. В чем разница между HashMap, TreeMap и LinkedHashMap?

HashMap — неупорядоченная коллекция, быстрая вставка и доступ по ключу, не гарантирует порядок.
LinkedHashMap — сохраняет порядок добавления элементов.
TreeMap — отсортирована по ключу, медленнее, но гарантирует упорядоченность (использует Comparable или Comparator).

3. Объясните разницу между методами get() и load() в Hibernate.

get() — немедленно извлекает объект из базы данных или возвращает null, если объект не найден.
Пример: session.get(User.class, 1);
Используется, когда нужно гарантированно получить объект.
load() — возвращает прокси-объект, и фактический запрос к базе выполняется только при первом доступе к полям (ленивая инициализация). Если объекта нет — выбрасывает ObjectNotFoundException.
Пример: session.load(User.class, 1);
Используется, когда уверены, что объект точно есть, и можно отложить загрузку.

4. Что такое каскадирование (cascade) в Hibernate и зачем оно нужно? 

Cascade (каскадирование) в Hibernate — это механизм, позволяющий автоматически применять операции (persist, merge, remove и т.д.) к связанным сущностям.
Это особенно полезно в отношениях @OneToMany, @ManyToOne, @OneToOne и @ManyToMany, когда нужно, например, сохранить не только родительскую сущность, но и связанные дочерние.
Возможные типы каскада:
    PERSIST
    MERGE
    REMOVE
    REFRESH
    DETACH
    ALL — применяет все вышеуказанные

5. Что такое final, и как он используется с переменными, методами и классами?

Ключевое слово final в Java означает, что сущность не может быть изменена после определения:
final переменная – нельзя изменить значение после присваивания.
final int x = 10;
x = 20; // ошибка компиляции
final метод – нельзя переопределить в подклассах.
class A {
    final void show() {}
}
class B extends A {
    void show() {} // ошибка
}
final класс – нельзя унаследовать от него.
final class A {}
class B extends A {} // ошибка
