
Short answers (1â€“2 Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ) Ğ¿Ğ¾Ğ´ ĞºĞ°Ğ¶Ğ´Ğ¾Ğµ Ğ¸Ğ· 100 ÑĞ»Ğ¾Ğ²,
Ğ² ÑÑ‚Ğ¸Ğ»Ğµ Oracle / Google interview: ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¾, Ñ‡Ñ‘Ñ‚ĞºĞ¾, Ğ¿Ğ¾ Ğ´ĞµĞ»Ñƒ.

ğŸ”¹ Core Java (1â€“30)

Class â€” A class is a blueprint for creating objects. It defines fields and methods.
Object â€” An object is an instance of a class representing real data.
Interface â€” An interface defines a contract that classes must implement.
Abstract class â€” An abstract class can contain both abstract and concrete methods.
Inheritance â€” Inheritance allows a class to reuse and extend another class.
Encapsulation â€” Encapsulation hides internal state and exposes behavior via methods.
Polymorphism â€” Polymorphism allows different implementations to be accessed through the same interface.
Immutability â€” An immutable object cannot be changed after creation.
Constructor â€” A constructor initializes a new object.
Method â€” A method defines behavior of a class.
Overloading â€” Overloading allows multiple methods with the same name but different parameters.
Overriding â€” Overriding replaces a parent class method with a new implementation.
Access modifier â€” Access modifiers control visibility of classes and members.
Final â€” final prevents modification, inheritance, or overriding.
Static â€” static members belong to the class, not to instances.
Primitive type â€” Primitive types store simple values directly.
Reference type â€” Reference types point to objects in memory.
Wrapper class â€” Wrapper classes convert primitives into objects.
Autoboxing â€” Autoboxing automatically converts primitives to wrapper objects.
Unboxing â€” Unboxing converts wrapper objects back to primitives.
Exception â€” An exception represents an error during program execution.
Checked exception â€” Checked exceptions must be handled at compile time.
Unchecked exception â€” Unchecked exceptions occur at runtime.
Try-catch â€” Try-catch blocks handle exceptions safely.
Throw / throws â€” throw creates an exception, throws declares it.
Garbage Collector â€” Garbage Collector automatically frees unused memory.
Heap â€” Heap stores objects and shared data.
Stack â€” Stack stores method calls and local variables.
Memory leak â€” A memory leak happens when unused objects are not released.
Thread-safe â€” Thread-safe code works correctly in concurrent environments.

ğŸ”¹ Collections & Concurrency (31â€“55)

Collection â€” A collection stores and manages groups of objects.
List â€” A List is an ordered collection that allows duplicates.
Set â€” A Set stores unique elements only.
Map â€” A Map stores key-value pairs.
HashMap â€” HashMap provides fast key-based access in average O(1) time.
ArrayList â€” ArrayList provides fast random access but slow insertions.
LinkedList â€” LinkedList allows fast insertions but slow random access.
TreeMap â€” TreeMap stores entries in sorted order.
HashSet â€” HashSet stores unique elements using hashing.
Iterator â€” Iterator allows sequential traversal of a collection.
Concurrency â€” Concurrency means multiple tasks progress at the same time.
Thread â€” A thread is a lightweight unit of execution.
Runnable â€” Runnable defines a task executed by a thread.
Synchronization â€” Synchronization prevents race conditions.
Lock â€” A lock controls access to shared resources.
Race condition â€” A race condition occurs when threads access shared data incorrectly.
Deadlock â€” Deadlock happens when threads wait forever for each other.
Volatile â€” volatile guarantees visibility of changes across threads.
Atomic â€” Atomic operations are executed as a single, indivisible step.
ExecutorService â€” ExecutorService manages thread pools efficiently.
Parallelism â€” Parallelism executes tasks simultaneously.
Asynchronous â€” Asynchronous execution does not block the caller.
Future â€” Future represents a result of an async computation.
CompletableFuture â€” CompletableFuture allows chaining async tasks.
Blocking â€” Blocking operations wait until completion.

ğŸ”¹ Algorithms & Performance (56â€“75)

Time complexity â€” Time complexity describes how runtime grows with input size.
Space complexity â€” Space complexity measures memory usage.
Big O notation â€” Big O describes the upper bound of complexity.
Linear time â€” Linear time grows proportionally with input size.
Logarithmic time â€” Logarithmic time grows very slowly.
Constant time â€” Constant time does not depend on input size.
Quadratic time â€” Quadratic time grows with the square of input size.
Worst case â€” Worst case is the maximum possible runtime.
Average case â€” Average case describes typical performance.
Best case â€” Best case is the fastest scenario.
Optimize â€” Optimization improves performance or memory usage.
In-place â€” In-place algorithms use constant extra memory.
Brute force â€” Brute force tries all possible solutions.
Greedy algorithm â€” Greedy algorithms make locally optimal choices.
Dynamic programming â€” Dynamic programming solves overlapping subproblems.
Recursion â€” Recursion is a function calling itself.
Binary search â€” Binary search finds elements in sorted data in O(log n).
Sorting â€” Sorting arranges data in a specific order.
Traversal â€” Traversal visits all elements of a structure.
Edge case â€” An edge case tests extreme or special inputs.

ğŸ”¹ System Design / Architecture (76â€“100)

Scalability â€” Scalability measures system growth capability.
Availability â€” Availability means the system is operational when needed.
Reliability â€” Reliability means consistent correct behavior.
Latency â€” Latency is the response delay.
Throughput â€” Throughput is the number of requests processed per second.
Microservices â€” Microservices split applications into independent services.
Monolith â€” A monolith is a single, tightly coupled application.
Distributed system â€” Distributed systems run on multiple machines.
Consistency â€” Consistency ensures all nodes see the same data.
CAP theorem â€” CAP states you can only fully guarantee two of three properties.
Transaction â€” A transaction is a unit of work with ACID properties.
Isolation level â€” Isolation levels control visibility of concurrent transactions.
Saga pattern â€” Saga manages distributed transactions via steps and compensations.
Compensating transaction â€” A compensating transaction undoes a previous step.
Event-driven â€” Event-driven systems react to events asynchronously.
REST API â€” REST APIs expose resources via HTTP.
Idempotent â€” Idempotent operations can be repeated safely.
Load balancing â€” Load balancing distributes traffic evenly.
Caching â€” Caching stores data for faster access.
Fault tolerance â€” Fault tolerance allows systems to survive failures.
Design pattern â€” Design patterns provide reusable solutions.
SOLID principles â€” SOLID improves maintainability and design quality.
Clean code â€” Clean code is readable and easy to maintain.
Technical debt â€” Technical debt represents future cost of shortcuts.
Trade-off â€” A trade-off balances competing design decisions.


//
//
// 
//

